<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * TODO:
 * - sorted CacheEngine
 * */

<span id='tupai-model-caches-QueueCache'>/**
</span> * @class   tupai.model.caches.QueueCache
 * @author &lt;a href='bocelli.hu@gmail.com'&gt;bocelli.hu&lt;/a&gt;
 * @docauthor &lt;a href='bocelli.hu@gmail.com'&gt;bocelli.hu&lt;/a&gt;
 * @since tupai.js 0.1
 *
 * cache data in queue
 * see {@link tupai.model.CacheManager}
 *
 */
Package('tupai.model.caches')
.use('tupai.util.MemCache')
.use('tupai.model.caches.QueueCacheDataSet')
.define('QueueCache', function(cp) { return Package.Class.extend({

<span id='tupai-model-caches-QueueCache-method-initialize'>    /**
</span>     * initialize
     * @param {String} name cache name
     * @param {Object} options
     * @param {Object} [options.memCache] memory cache config
     * @param {Object} [options.uniqField] memory cache config
     * @param {Number} [options.memCache.limit] memory cache limit
     * @param {Number} [options.memCache.overflowRemoveSize] number of remove items when reach limit of cache
     * @param {Object} [options.localStorage] use localStorage
     * @param {Object} [options.sesseionStorage] use sesseionStorage
     * see {@link tupai.model.CacheManager#createCache}
     *
     */
    initialize: function(name, options, delegate) {

        options = options || {};

        var limit, overflowRemoveSize;
        if(options.memCache) {
            var c = options.memCache;
            limit = c.limit;
            overflowRemoveSize = c.overflowRemoveSize;
        }
        this._storage = new cp.MemCache(limit, overflowRemoveSize);
        this._storage.setDelegate(this);
        this._attributes = options.attributes;

        if(options.localStorage) {
            this._nativeStorage = window.localStorage;
            this._nativeStorageDefaultMeta = { version: 1 };
        } else if(options.sessionStorage) {
            this._nativeStorage = window.sessionStorage;
            this._nativeStorageDefaultMeta = { version: 1 };
        }
        if(this._nativeStorage) {
            this._nativeStorageKey = '__tupai_'+name;
            var dataText = this._nativeStorage.getItem(this._nativeStorageKey);
            if(dataText) {
                var d = JSON.parse(dataText);
                if(d.m &amp;&amp; d.d) {
                    this._storage.swapStorage(d.d);
                    this._meta = d.m;
                } else {
                    console.warn('unknow native storage format!');
                }
            }
        }

        this._uniqField = options.uniqField;
        this._delegate = delegate;
        this._name = name;
    },

<span id='tupai-model-caches-QueueCache-method-getCreated'>    /**
</span>     * get the storage data created timestamp
     * this function will return null when memory cache only.
     */
    getCreated: function() {
        return this._meta &amp;&amp; this._meta.created;
    },

    didMemCacheGC: function() {
        this._saveToNative();
        this._delegate &amp;&amp;
        this._delegate.didCacheGC &amp;&amp;
        this._delegate.didCacheGC(this._name, this);
    },

<span id='tupai-model-caches-QueueCache-method-getName'>    /**
</span>     * get cache name
     * @return {String} name
     *
     */
    getName: function() {
        return this._name;
    },

<span id='tupai-model-caches-QueueCache-method-notifyDataSetChanged'>    /**
</span>     * notify cache has been changed
     * @param {Object} [options] custom options
     *
     */
    notifyDataSetChanged : function(options) {
        this._saveToNative();
        this._delegate &amp;&amp;
        this._delegate.didCacheChanged &amp;&amp;
        this._delegate.didCacheChanged(this._name, this, options);
    },
    _saveToNative: function() {
        if(this._nativeStorage) {
            var meta = this._meta;
            if(!meta) {
                meta = this._meta = {};
                for(var name in this._nativeStorageDefaultMeta) {
                    meta[name] = this._nativeStorageDefaultMeta[name];
                }
            }
            meta.created = (Date.now?Date.now():(+new Date()));
            var d = {
                m: meta,
                d: this._storage.getStorage()
            };
            this._nativeStorage.setItem(this._nativeStorageKey, JSON.stringify(d));
        }
    },

<span id='tupai-model-caches-QueueCache-method-end'>    /**
</span>     * end edit the cache and notify cache has been changed
     * @param {Object} [options] custom options
     *
     */
    end: function(options) {
        this.notifyDataSetChanged(options);
    },

<span id='tupai-model-caches-QueueCache-method-query'>    /**
</span>     * query cache and return {@link tupai.model.DataSet DataSet}
     * @param {Object} args sess {@link tupai.model.DataSet}
     * @return {tupai.model.DataSet} DataSet
     *
     */
    query: function(args) {
        var set = new cp.QueueCacheDataSet(this._storage, args);
        return set;
    },

<span id='tupai-model-caches-QueueCache-method-getAttribute'>    /**
</span>     * get custom attribute by name.
     * @param {String} name attribute name
     * @return {Object} attribute value
     *
     */
    getAttribute: function(name) {
        return this._attributes &amp;&amp; this._attributes[name];
    },

<span id='tupai-model-caches-QueueCache-method-setAttribute'>    /**
</span>     * set custom attribute by name.
     * @param {String} name attribute name
     * @param {Object} value attribute value
     * @return {Object} old attribute value
     *
     */
    setAttribute: function(name, value) {
        if(!this._attributes) {
            this._attributes = {};
        }
        var old = this._attributes[name];
        this._attributes[name] = value;
        return old;
    },

<span id='tupai-model-caches-QueueCache-method-push'>    /**
</span>     * push data to cache. the method will not notify cache changed.
     * you need to call end function to end edit and notify cache changed.
     * @param {Object} data
     *
     */
    push: function(data) {

        if(this._uniqField) data = this._removeDup(data);
        if(data instanceof Array) {
            this._storage.concat(data);
        } else {
            this._storage.push(data);
        }
    },

<span id='tupai-model-caches-QueueCache-method-unshift'>    /**
</span>     * push data to top of cache
     * @param {Object} data
     *
     */
    unshift: function(data) {

        if(this._uniqField) data = this._removeDup(data);

        if(data instanceof Array) {
            this._storage.concatFirst(data);
        } else {
            this._storage.unshift(data);
        }
    },

    _removeDup: function(data) {

        var newKeys = {};
        var uniqField = this._uniqField;
        if(data instanceof Array) {
            var newData=[];
            for(var i=0, n=data.length; i&lt;n; i++) {
                var r = data[i];
                var key = r[uniqField];
                if(!newKeys[key]) {
                    newData.push(r);
                }
                newKeys[key] = true;
            }
            data = newData;
        } else {
            newKeys[data[uniqField]] = true;
        }

        this._storage.filter(function(d) {
            var key = d[uniqField];
            return !(newKeys[key]);
        });

        return data;
    },

<span id='tupai-model-caches-QueueCache-method-filter'>    /**
</span>     * Creates a new array with all of the elements of this array for which the provided filtering function returns true.
     * @param {Function} callback
     * @param {Boolean} [noNotify=false] set this parameter to true will not notify cache changed.
     *
     */
    filter: function(callback, noNotify) {
        var oldSize = this.size();
        this._storage.filter(callback);
        if(!noNotify &amp;&amp; this.size() != oldSize) {
            this._delegate.didCacheChanged(this._name, this);
        }
    },

<span id='tupai-model-caches-QueueCache-method-iterator'>    /**
</span>     * iterate cache item
     * @param {Function} callback
     *
     */
    iterator: function(callback) {
        this._storage.iterator(callback);
    },

<span id='tupai-model-caches-QueueCache-method-remove'>    /**
</span>     * remove element by index
     * @param {Number} index
     *
     */
    remove: function(index) {
        return this._storage.remove(index);
    },

<span id='tupai-model-caches-QueueCache-method-removeByElement'>    /**
</span>     * remove element
     * @param {Object} element
     *
     */
    removeByElement: function(data) {
        return this._storage.remove(data);
    },

<span id='tupai-model-caches-QueueCache-method-clear'>    /**
</span>     * clear cache
     *
     */
    clear: function() {
        this._storage.clear();
    },

<span id='tupai-model-caches-QueueCache-method-get'>    /**
</span>     * get cache by index
     * @param {Number} index
     *
     */
    get: function(index) {
        return this._storage.get(index);
    },

<span id='tupai-model-caches-QueueCache-method-size'>    /**
</span>     * get size of cache items
     *
     */
    size: function() {
        return this._storage.size();
    }
});});
</pre>
</body>
</html>
